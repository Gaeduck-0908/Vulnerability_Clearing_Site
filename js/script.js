var vulnerabilities;

// 비동기로 JSON 파일 읽기
async function loadJSON() {
    const response = await fetch('json/vuln.json');
    vulnerabilities = await response.json();
    updateCategories();
}

loadJSON();

function updateCategories() {
    var categorySelect = document.getElementById('category');

    for (var category in vulnerabilities) {
        var option = document.createElement('option');
        option.value = category;
        option.text = category;
        categorySelect.add(option);
    }
    updateVulnerabilities();
}

function updateVulnerabilities() {
    var category = document.getElementById('category').value;
    var vulnerabilitySelect = document.getElementById('vulnerability');

    vulnerabilitySelect.innerHTML = '';

    var categoryVulnerabilities = vulnerabilities[category];
    if (categoryVulnerabilities) {
        categoryVulnerabilities.forEach(function (vulnerability) {
            var option = document.createElement('option');
            option.value = vulnerability;
            option.text = vulnerability;
            vulnerabilitySelect.add(option);
        });
    }
}

function generateReport() {
    var category = document.getElementById('category').value;
    var vulnerability = document.getElementById('vulnerability').value;
    var url = document.getElementById('url').value;
    var parm = document.getElementById('parm').value;
    var payload = document.getElementById('payload').value;
    var description = document.getElementById('description').value;

    var resultText = `[${category}]\n----------------------------\n취약점 : ${vulnerability}\n타겟 URL : ${url}\n타겟 PARM : ${parm}\n\n사용된 PAYLOAD : \n${payload}\n\n간단 설명 : \n${description}`;

    document.getElementById('result').innerText = resultText;

    var downloadLink = document.getElementById('downloadLink');
    downloadLink.href = 'data:text/plain;charset=utf-8,' + encodeURIComponent(resultText);
    downloadLink.style.display = 'block';
}

updateCategories();